--- a/lib/gemini.ts
+++ b/lib/gemini.ts
@@ -1446,63 +1446,20 @@
 function fixScriptFormatting(response: string): string {
   let processedResponse = response;
   
-  // Step 1: Preserve and standardize scene headings (INT./EXT./INT-EXT.)
-  // More flexible regex to catch various formats including those without time
-  processedResponse = processedResponse.replace(
-    /(\*\*?)?(INT\.|EXT\.|INT\/EXT\.|INT-EXT\.)\s*([^*\n]+?)(\*\*?)?/g,
-    (match, startBold, sceneType, location, endBold) => {
-      // Always ensure scene headings are bold
-      return `**${sceneType} ${location.trim()}**`;
-    }
-  );
-  
-  // Step 2: Preserve character names (ALL CAPS, possibly with parentheticals)
-  processedResponse = processedResponse.replace(
-    /(\*\*?)([A-Z][A-Z\s]+(?:\([^)]+\))?)(\*\*?)/g,
-    (match, startBold, charName, endBold) => {
-      // Only bold if it looks like a character name (ALL CAPS)
-      if (charName.match(/^[A-Z][A-Z\s]+(?:\([^)]+\))?$/)) {
-        return `**${charName.trim()}**`;
-      }
-      return charName; // Remove bold for non-character names
-    }
-  );
-  
-  // Step 3: Remove ** from other content (action lines, dialogue, etc.)
-  processedResponse = processedResponse.replace(/\*\*([^*]+?)\*\*/g, (match, content) => {
-    // Check if it's already a scene heading or character name
-    if (content.match(/^(INT\.|EXT\.|INT\/EXT\.|INT-EXT\.)/) || 
-        content.match(/^[A-Z][A-Z\s]+(?:\([^)]+\))?$/)) {
-      return match; // Keep the ** formatting
-    }
-    return content; // Remove ** for other content
-  });
-  
-  // Third pass: Clean up any remaining unwanted ** patterns (but preserve script formatting)
-  processedResponse = processedResponse.replace(/\*\*([^*]+):\*\*/g, '$1:');
-  processedResponse = processedResponse.replace(/\*\*([^*]+) \(([^)]+)\):\*\*/g, '$1 ($2):');
-  
-  // Fourth pass: Clean up any double spaces or formatting issues
+  // Step 1: Remove chunking markers and internal metadata
+  processedResponse = processedResponse.replace(/\n\s*\[SCENE END\]\s*\n?/g, '');
+  processedResponse = processedResponse.replace(/\n\s*\[SCENE START\]\s*\n?/g, '');
+  processedResponse = processedResponse.replace(/\n\s*\[CHUNK \d+\]\s*\n?/g, '');
+  processedResponse = processedResponse.replace(/\n\s*\[PAGE \d+\]\s*\n?/g, '');
+  processedResponse = processedResponse.replace(/\n\s*\[PART \d+\]\s*\n?/g, '');
+  
+  // Step 2: Remove all ** formatting (let frontend handle styling)
+  processedResponse = processedResponse.replace(/\*\*/g, '');
+  
+  // Step 3: Clean up spacing and formatting
   processedResponse = processedResponse.replace(/\n\s*\n\s*\n/g, '\n\n');
   processedResponse = processedResponse.replace(/[ \t]+/g, ' ');
   
-  // Fifth pass: Remove chunking markers and internal metadata
-  processedResponse = processedResponse.replace(/\n\s*\[SCENE END\]\s*\n?/g, '');
-  processedResponse = processedResponse.replace(/\n\s*\[SCENE START\]\s*\n?/g, '');
-  processedResponse = processedResponse.replace(/\n\s*\[CHUNK \d+\]\s*\n?/g, '');
-  processedResponse = processedResponse.replace(/\n\s*\[PAGE \d+\]\s*\n?/g, '');
-  processedResponse = processedResponse.replace(/\n\s*\[PART \d+\]\s*\n?/g, '');
-  
-  // Sixth pass: Remove final endings that close the story
+  // Step 4: Remove story endings
   processedResponse = processedResponse.replace(/\n\s*FADE OUT\.?\s*$/g, '');
   processedResponse = processedResponse.replace(/\n\s*THE END\.?\s*$/g, '');
   processedResponse = processedResponse.replace(/\n\s*END\.?\s*$/g, '');
   processedResponse = processedResponse.replace(/\n\s*FIN\.?\s*$/g, '');
   
-  // Debug: Log scene headings that were processed
-  const sceneHeadings = processedResponse.match(/\*\*(INT\.|EXT\.|INT\/EXT\.|INT-EXT\.)\s*[^*]+\*\*/g);
-  if (sceneHeadings && sceneHeadings.length > 0) {
-    console.log('Scene headings processed:', sceneHeadings.length);
-  }
-  
   return processedResponse;
 }
